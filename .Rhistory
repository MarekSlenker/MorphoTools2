new.xy <- expand.grid(x = new.x, y = new.y)
inside <- as.logical(pip(new.xy$x, new.xy$y, x[xy.hull],
y[xy.hull]))
fit <- predict(tmp, type = "response", newdata = as.data.frame(new.xy))
fit[!inside] <- NA
contour(x = new.x, y = new.y, z = matrix(fit, nrow = grid),
add = TRUE, col = col, lwd = 2)
}
dd = read.morphodata("clipboard")
cda.res = pcoa.calc(dd)
cda.res = pcoa.calc(dd)
dd = read.morphodata("clipboard")
cda.res = pcoa.calc(dd)
cda.res = pcoa.calc(dd)
object=dd
min(length(colnames(object$data)), length(rownames(object$data)))
min(length(colnames(object$data)), length(rownames(object$data)))-1
rank = min(length(colnames(object$data)), length(rownames(object$data)))-1 # maximum dimension of the space must be in {1, 2, …, n-1}.
xRes = stats::cmdscale(.calcDistance(object, distMethod = distMethod, center = TRUE, scale = TRUE, binaryChs = binaryChs, nominalChs = nominalChs, ordinalChs = ordinalChs),
eig = TRUE) # only to find numb of possitive eigenvalues
.calcDistance <- function(object, distMethod, center, scale, binaryChs, nominalChs, ordinalChs) {
switch (tolower(distMethod),
"euclidean" = {  # moze byt scale alebo nie
return(
stats::dist(scale(object$data, center = center, scale = scale), method = "euclidean")
)
},
"jaccard" = { # ziadne scale
if (any(is.na(object$data))) stop("NA values in 'object'.", call. = FALSE)
return(
ade4::dist.binary(object$data, method = 1, diag = FALSE, upper = FALSE)
)
},
"simplematching" = {
if (any(is.na(object$data))) stop("NA values in 'object'.", call. = FALSE)
return(
ade4::dist.binary(object$data, method = 2, diag = FALSE, upper = FALSE)
)
},
"gower" = {
if (! is.null(binaryChs)) {
object$data[binaryChs] = lapply(object$data[binaryChs], as.logical)
}
if (! is.null(nominalChs)) {
object$data[nominalChs] = lapply(object$data[nominalChs], as.character)
}
if (! is.null(ordinalChs)) {
object$data[ordinalChs] = lapply(object$data[ordinalChs], ordered)
}
return(
stats::as.dist(StatMatch::gower.dist(object$data))
)
},
"manhattan" = {
return(
stats::dist(object$data, method = "manhattan", diag = FALSE, upper = FALSE)
)
},
"minkowski" = {
return(
stats::dist(object$data, method = "minkowski", diag = FALSE, upper = FALSE)
)
},
stop(paste("distMethod \"", distMethod , "\" is not supported.", sep = ""), call. = FALSE)
)
}
xRes = stats::cmdscale(.calcDistance(object, distMethod = distMethod, center = TRUE, scale = TRUE, binaryChs = binaryChs, nominalChs = nominalChs, ordinalChs = ordinalChs),
eig = TRUE) # only to find numb of possitive eigenvalues
distMethod = "Euclidean"
binaryChs = NULL
nominalChs = NULL
ordinalChs = NULL
xRes = stats::cmdscale(.calcDistance(object, distMethod = distMethod, center = TRUE, scale = TRUE, binaryChs = binaryChs, nominalChs = nominalChs, ordinalChs = ordinalChs),
eig = TRUE) # only to find numb of possitive eigenvalues
rank = length(xRes$eig[which(xRes$eig > 0)])
rank
princompRes = stats::cmdscale(.calcDistance(object, distMethod = distMethod, center = TRUE, scale = TRUE, binaryChs = binaryChs, nominalChs = nominalChs, ordinalChs = ordinalChs),
k = rank, eig = TRUE, x.ret = TRUE)
rank
princompRes = stats::cmdscale(.calcDistance(object, distMethod = distMethod, center = TRUE, scale = TRUE, binaryChs = binaryChs, nominalChs = nominalChs, ordinalChs = ordinalChs),
k = rank, eig = TRUE, x.ret = TRUE)
stats::dist(scale(object$data, center = center, scale = scale), method = "euclidean")
center = TRUE
scale = TRUE
stats::dist(scale(object$data, center = center, scale = scale), method = "euclidean")
.calcDistance <- function(object, distMethod, center, scale, binaryChs, nominalChs, ordinalChs) {
switch (tolower(distMethod),
"euclidean" = {  # moze byt scale alebo nie
return(
stats::dist(scale(object$data, center = center, scale = scale), method = "euclidean")
)
},
"jaccard" = { # ziadne scale
if (any(is.na(object$data))) stop("NA values in 'object'.", call. = FALSE)
return(
ade4::dist.binary(object$data, method = 1, diag = FALSE, upper = FALSE)
)
},
"simplematching" = {
if (any(is.na(object$data))) stop("NA values in 'object'.", call. = FALSE)
return(
ade4::dist.binary(object$data, method = 2, diag = FALSE, upper = FALSE)
)
},
"gower" = {
if (! is.null(binaryChs)) {
object$data[binaryChs] = lapply(object$data[binaryChs], as.logical)
}
if (! is.null(nominalChs)) {
object$data[nominalChs] = lapply(object$data[nominalChs], as.character)
}
if (! is.null(ordinalChs)) {
object$data[ordinalChs] = lapply(object$data[ordinalChs], ordered)
}
return(
stats::as.dist(StatMatch::gower.dist(object$data))
)
},
"manhattan" = {
return(
stats::dist(object$data, method = "manhattan", diag = FALSE, upper = FALSE)
)
},
"minkowski" = {
return(
stats::dist(object$data, method = "minkowski", diag = FALSE, upper = FALSE)
)
},
stop(paste("distMethod \"", distMethod , "\" is not supported.", sep = ""), call. = FALSE)
)
}
stats::cmdscale(.calcDistance(object, distMethod = distMethod, center = TRUE, scale = TRUE, binaryChs = binaryChs, nominalChs = nominalChs, ordinalChs = ordinalChs),
k = rank, eig = TRUE, x.ret = TRUE)
k = rank
rank
length(xRes$eig[which(xRes$eig > 0)])
xRes$eig
xRes$eig[which(xRes$eig > 0)]
length(xRes$eig[which(xRes$eig > 0)])
rank
rank = min(length(colnames(object$data)), length(rownames(object$data)))-1 # maximum dimension of the space must be in {1, 2, …, n-1}.
min(length(colnames(object$data)), length(rownames(object$data)))-1 # maximum dimension of the space must be in {1, 2, …, n-1}.
stats::cmdscale(.calcDistance(object, distMethod = distMethod, center = TRUE, scale = TRUE, binaryChs = binaryChs, nominalChs = nominalChs, ordinalChs = ordinalChs),
k = rank, eig = TRUE, x.ret = TRUE)
length(xRes$eig[which(xRes$eig > 0)])
length(xRes$eig[which(xRes$eig > 0)])
length(rownames(object$data)))
length(rownames(object$data))
length(colnames(object$data))
length(rownames(object$data))
length(xRes$eig[which(xRes$eig > 0)])
length(rownames(object$data))-1
length(colnames(object$data))-1
min(length(colnames(object$data))-1, length(rownames(object$data))-1, length(xRes$eig[which(xRes$eig > 0)]) ) # maximum dimension of the space must be in {1, 2, …, n-1}.
dd = read.morphodata("clipboard")
cda.res = pcoa.calc(dd)
dd = read.morphodata("clipboard")
cda.res = pcoa.calc(dd)
dd = read.morphodata("clipboard")
cda.res = pcoa.calc(dd)
dd = read.morphodata("clipboard")
cda.res = pcoa.calc(dd)
object = read.morphodata("clipboard")
rank = min(length(colnames(object$data)), length(rownames(object$data)))-1 # maximum dimension of the space must be in {1, 2, …, n-1}.
xRes = stats::cmdscale(.calcDistance(object, distMethod = distMethod, center = TRUE, scale = TRUE, binaryChs = binaryChs, nominalChs = nominalChs, ordinalChs = ordinalChs),
eig = TRUE) # only to find numb of possitive eigenvalues
length(xRes$eig[which(xRes$eig > 0)])
length(xRes$eig)
length(colnames(object$data))-1
length(xRes$eig[which(xRes$eig > 0)])
rank = length(xRes$eig[which(xRes$eig > 0)])  # maximum dimension of the space must be in {1, 2, …, n-1}.
princompRes = stats::cmdscale(.calcDistance(object, distMethod = distMethod, center = TRUE, scale = TRUE, binaryChs = binaryChs, nominalChs = nominalChs, ordinalChs = ordinalChs),
k = rank, eig = TRUE, x.ret = TRUE)
rank = length(xRes$eig)
princompRes = stats::cmdscale(.calcDistance(object, distMethod = distMethod, center = TRUE, scale = TRUE, binaryChs = binaryChs, nominalChs = nominalChs, ordinalChs = ordinalChs),
k = rank, eig = TRUE, x.ret = TRUE)
rank
rank = length(xRes$eig[which(xRes$eig > 0)])  # maximum dimension of the space must be in {1, 2, …, n-1}.
princompRes = stats::cmdscale(.calcDistance(object, distMethod = distMethod, center = TRUE, scale = TRUE, binaryChs = binaryChs, nominalChs = nominalChs, ordinalChs = ordinalChs),
k = rank, eig = TRUE, x.ret = TRUE)
rank = length(xRes$eig)
princompRes = stats::cmdscale(.calcDistance(object, distMethod = distMethod, center = TRUE, scale = TRUE, binaryChs = binaryChs, nominalChs = nominalChs, ordinalChs = ordinalChs),
k = rank, eig = TRUE, x.ret = TRUE)
rank = length(xRes$eig)
rank = length(xRes$eig[which(xRes$eig > 0)])  # maximum dimension of the space must be in {1, 2, …, n-1}.
length(xRes$eig[which(xRes$eig > 0)])
length(xRes$eig[which(xRes$eig > 0)]) == length(xRes$eig)
length(xRes$eig)
length(xRes$eig)-1
main("ds")
title("ds")
plot(cda.res, col = c("blue", "green", "red") , legend = T)
{
pip <- function (x,y,polyx,polyy)
{
z <- rep(0,length(x))
res <- .Fortran("pip",
as.double(x),
as.double(y),
as.integer(z),
as.double(polyx),
as.double(polyy),
as.integer(length(x)),
as.integer(length(polyx)),
PACKAGE='labdsv')
return(res[[3]])
}
if (thinplate) {
tmp <- gam(var ~ s(x, y), family = family, gamma = gamma)
} else {
tmp <- gam(var ~ s(x) + s(y), family = family, gamma = gamma)
}
new.x <- seq(min(x), max(x), len = grid)
new.y <- seq(min(y), max(y), len = grid)
xy.hull <- chull(x, y)
xy.hull <- c(xy.hull, xy.hull[1])
new.xy <- expand.grid(x = new.x, y = new.y)
inside <- as.logical(pip(new.xy$x, new.xy$y, x[xy.hull],
y[xy.hull]))
fit <- predict(tmp, type = "response", newdata = as.data.frame(new.xy))
fit[!inside] <- NA
contour(x = new.x, y = new.y, z = matrix(fit, nrow = grid),
add = TRUE, col = col, lwd = 2)
}
title("PCoA s WTS_LTS, s premietnutym WTS_LTS ako ciary")
plot(cda.res, col = c("blue", "green", "red") , legend = T)
{
pip <- function (x,y,polyx,polyy)
{
z <- rep(0,length(x))
res <- .Fortran("pip",
as.double(x),
as.double(y),
as.integer(z),
as.double(polyx),
as.double(polyy),
as.integer(length(x)),
as.integer(length(polyx)),
PACKAGE='labdsv')
return(res[[3]])
}
if (thinplate) {
tmp <- gam(var ~ s(x, y), family = family, gamma = gamma)
} else {
tmp <- gam(var ~ s(x) + s(y), family = family, gamma = gamma)
}
new.x <- seq(min(x), max(x), len = grid)
new.y <- seq(min(y), max(y), len = grid)
xy.hull <- chull(x, y)
xy.hull <- c(xy.hull, xy.hull[1])
new.xy <- expand.grid(x = new.x, y = new.y)
inside <- as.logical(pip(new.xy$x, new.xy$y, x[xy.hull],
y[xy.hull]))
fit <- predict(tmp, type = "response", newdata = as.data.frame(new.xy))
fit[!inside] <- NA
contour(x = new.x, y = new.y, z = matrix(fit, nrow = grid),
add = TRUE, col = col, lwd = 2)
}
title("PCoA s WTS/LTS, s premietnutym WTS/LTS ako ciary")
library(MorphoTools2)
dd = read.morphodata("clipboard")
elev = read.delim("clipboard", header = F)
cda.res = pcoa.calc(dd)
var = elev$V1
x <- cda.res$objects$scores[,1]
y <- cda.res$objects$scores[,2]
thinplate = FALSE  # a logical variable to control the fitting routine: thinplate=TRUE (the default)
# fits a thinplate spline, thinplate=FALSE fits independent smooth splines. If you
# have too few data points you may have to specify thinplate=FALSE
family = gaussian  # controls the link function passed to 'gam': one of 'gaussian', 'binomial', 'poisson' or 'nb'
gamma = 1          # controls the smoothness of the fit from gam
grid = 50
col = "black"
plot(cda.res, col = c("blue", "green", "red") , legend = T)
plot(cda.res, col = c("blue", "green", "red") , legend = F)
{
pip <- function (x,y,polyx,polyy)
{
z <- rep(0,length(x))
res <- .Fortran("pip",
as.double(x),
as.double(y),
as.integer(z),
as.double(polyx),
as.double(polyy),
as.integer(length(x)),
as.integer(length(polyx)),
PACKAGE='labdsv')
return(res[[3]])
}
if (thinplate) {
tmp <- gam(var ~ s(x, y), family = family, gamma = gamma)
} else {
tmp <- gam(var ~ s(x) + s(y), family = family, gamma = gamma)
}
new.x <- seq(min(x), max(x), len = grid)
new.y <- seq(min(y), max(y), len = grid)
xy.hull <- chull(x, y)
xy.hull <- c(xy.hull, xy.hull[1])
new.xy <- expand.grid(x = new.x, y = new.y)
inside <- as.logical(pip(new.xy$x, new.xy$y, x[xy.hull],
y[xy.hull]))
fit <- predict(tmp, type = "response", newdata = as.data.frame(new.xy))
fit[!inside] <- NA
contour(x = new.x, y = new.y, z = matrix(fit, nrow = grid),
add = TRUE, col = col, lwd = 2)
}
title("PCoA BEZ WTS_LTS, s premietnutym WTS_LTS ako ciary")
dd =read.morphodata("clipboard")
pcoaRes = pcoa.calc(dd)
plotPoints(pcoaRes)
pcoaRes$eigenvalues
dd =read.morphodata("clipboard")
pcoaRes = pcoa.calc(dd)
plotPoints(pcoaRes)
pcoaRes$eigenvalues
pcoaRes$eigenvaluesAsPercentages
pcoaRes$cumulativePercentageOfEigenvalues
git config --global user.email "marek.slenker@savba.sk"
git config --global user.name "MarekSlenker"
dd = read.morphodata("clipboard")
elev = read.delim("clipboard", header = F)
cda.res = pcoa.calc(dd)
var = elev$V1
x <- cda.res$objects$scores[,1]
y <- cda.res$objects$scores[,2]
thinplate = FALSE  # a logical variable to control the fitting routine: thinplate=TRUE (the default)
# fits a thinplate spline, thinplate=FALSE fits independent smooth splines. If you
# have too few data points you may have to specify thinplate=FALSE
family = gaussian  # controls the link function passed to 'gam': one of 'gaussian', 'binomial', 'poisson' or 'nb'
gamma = 1          # controls the smoothness of the fit from gam
grid = 50
col = "black"
plot(cda.res, col = c("blue", "green", "red") , legend = F)
{
pip <- function (x,y,polyx,polyy)
{
z <- rep(0,length(x))
res <- .Fortran("pip",
as.double(x),
as.double(y),
as.integer(z),
as.double(polyx),
as.double(polyy),
as.integer(length(x)),
as.integer(length(polyx)),
PACKAGE='labdsv')
return(res[[3]])
}
if (thinplate) {
tmp <- gam(var ~ s(x, y), family = family, gamma = gamma)
} else {
tmp <- gam(var ~ s(x) + s(y), family = family, gamma = gamma)
}
new.x <- seq(min(x), max(x), len = grid)
new.y <- seq(min(y), max(y), len = grid)
xy.hull <- chull(x, y)
xy.hull <- c(xy.hull, xy.hull[1])
new.xy <- expand.grid(x = new.x, y = new.y)
inside <- as.logical(pip(new.xy$x, new.xy$y, x[xy.hull],
y[xy.hull]))
fit <- predict(tmp, type = "response", newdata = as.data.frame(new.xy))
fit[!inside] <- NA
contour(x = new.x, y = new.y, z = matrix(fit, nrow = grid),
add = TRUE, col = col, lwd = 2)
}
title("PCoA s WTS_LTS, s premietnutym WTS_LTS ako ciary")
dd = read.morphodata("clipboard")
cda.res = pcoa.calc(dd)
var = elev$V1
x <- cda.res$objects$scores[,1]
y <- cda.res$objects$scores[,2]
thinplate = FALSE  # a logical variable to control the fitting routine: thinplate=TRUE (the default)
# fits a thinplate spline, thinplate=FALSE fits independent smooth splines. If you
# have too few data points you may have to specify thinplate=FALSE
family = gaussian  # controls the link function passed to 'gam': one of 'gaussian', 'binomial', 'poisson' or 'nb'
gamma = 1          # controls the smoothness of the fit from gam
grid = 50
col = "black"
plot(cda.res, col = c("blue", "green", "red") , legend = F)
{
pip <- function (x,y,polyx,polyy)
{
z <- rep(0,length(x))
res <- .Fortran("pip",
as.double(x),
as.double(y),
as.integer(z),
as.double(polyx),
as.double(polyy),
as.integer(length(x)),
as.integer(length(polyx)),
PACKAGE='labdsv')
return(res[[3]])
}
if (thinplate) {
tmp <- gam(var ~ s(x, y), family = family, gamma = gamma)
} else {
tmp <- gam(var ~ s(x) + s(y), family = family, gamma = gamma)
}
new.x <- seq(min(x), max(x), len = grid)
new.y <- seq(min(y), max(y), len = grid)
xy.hull <- chull(x, y)
xy.hull <- c(xy.hull, xy.hull[1])
new.xy <- expand.grid(x = new.x, y = new.y)
inside <- as.logical(pip(new.xy$x, new.xy$y, x[xy.hull],
y[xy.hull]))
fit <- predict(tmp, type = "response", newdata = as.data.frame(new.xy))
fit[!inside] <- NA
contour(x = new.x, y = new.y, z = matrix(fit, nrow = grid),
add = TRUE, col = col, lwd = 2)
}
title("PCoA BEZ WTS_LTS, s premietnutym WTS_LTS ako ciary")
library(MorphoTools2)
dd = read.morphodata("clipboard")
cdaRes = cda.calc(dd)
plotPoints(cdaRes)
plotPoints(cdaRes, col = c("red", "green"))
plotPoints(cdaRes, col = c("red", "green"), breaks = 2)
plotPoints(cdaRes, col = c("red", "green"), breaks = 0.5)
plotPoints(cdaRes, col = c("red", "green"), breaks = 0.1)
plotCharacters(cdaRes)
boxplotAll(dd)
cdaRes
cdaRes$objects$scores[1:9]
cdaRes$objects$scores[,1:9]
cdaRes$objects$scores[1:9,]
c(cdaRes$objects$scores[1:9,], cdaRes$objects$scores)
cdaRes$objects$scores[1:9,]
cdaRes$objects$scores
length(cdaRes$objects$scores)
length(cdaRes$objects$scores$Can1)
c(cdaRes$objects$scores[1:9,], cdaRes$objects$scores$Can1)
cdaRes$objects$scores$Can1 = c(cdaRes$objects$scores[1:9,], cdaRes$objects$scores$Can1)
cdaRes$objects$scores = c(cdaRes$objects$scores[1:9,], cdaRes$objects$scores$Can1)
cdaRes$objects$scores = c(cdaRes$objects$scores[1:9,], cdaRes$objects$scores$Can1)
cdaRes$objects$scores
cdaRes$objects$scores[1:9]
cdaRes$objects$scores = c(cdaRes$objects$scores[1:9], cdaRes$objects$scores$Can1)
cdaRes$objects$scores = c(cdaRes$objects$scores[1:9], cdaRes$objects$scores)
cdaRes$objects
cdaRes$objects$Taxon[1:9]
cdaRes$objects$Taxon = c(cdaRes$objects$Taxon[1:9], cdaRes$objects$Taxon)
cdaRes$objects$Taxon = c(cdaRes$objects$Taxon[1:9], cdaRes$objects$Taxon)
cdaRes$objects$Taxon
plotCharacters(cdaRes)
plotPoints(cdaRes)
boxplotCharacter(dd, "WLS")
boxplotCharacter(dd, "WLS")
boxplotCharacter(dd, "LC3")
boxplotCharacter(dd, "WTS")
boxplotCharacter(dd, "LLS")
boxplotCharacter(dd, "WLS")
install.packages("rmarkdown")
tinytex::install_tinytex()
library(MorphoTools2)
library(MorphoTools2)
library(MorphoTools2)
devtools::check_rhub()
update.packages(ask = FALSE, checkBuilt = TRUE)
tinytex::tlmgr_update()
rhub::check_for_cran()
devtools::check_win_devel()
devtools::spell_check()
goodpractice::gp()
install.packages("goodpractice")
goodpractice::gp()
object = data("centaurea")
meansubst<-function(x){
m<-mean(x,na.rm=T)
if (is.nan(m)) m<-NA
x[which(is.na(x))]<-m
x = round(x, digits = 3)
return(x)}
populs<-levels(object$Population)
object
data(centaurea)
data(centaurea)
object = centaurea
populs<-levels(object$Population)
populs
pop="CERM"
popPositions = which( object$Population %in% pop)
sapply(object$data[popPositions,], meansubst)
vapply(object$data[popPositions,], meansubst)
vapply(object$data[popPositions,], double, meansubst)
dataTaxon = object$data[which( object$Taxon %in% tax), ][character]
# a teraz ho zmen
taxa = levels(object$Taxon)
taxa
tax="ps"
dataTaxon = object$data[which( object$Taxon %in% tax), ][character]
character="LL"
dataTaxon = object$data[which( object$Taxon %in% tax), ][character]
upWhisker = as.numeric( stats::quantile(dataTaxon, probs = upperWhisker, na.rm = TRUE)  )
loWhisker = as.numeric( stats::quantile(dataTaxon, probs = lowerWhisker, na.rm = TRUE)  )
1:nrow(dataTaxon)
seq_len(dataTaxon)
inteRgrate::check_pkg()
inteRgrate::check_pkg()
install.packages("inteRgrate")
devtools::check_win_devel()
devtools::build_manual()
devtools::build_manual()
devtools::build_manual()
devtools::build_readme()
devtools::build_manual(path = ".")
devtools::build_manual(path = "../")
install.packages("RdUtils")
devtools::build()
devtools::check_win_devel()
devtools::check_win_devel()
