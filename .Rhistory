str(sW)
a= stepdisc.calc(centaurea)
str(a)
a=  transformCharacter(centaurea, character = "SF", FUN = function(x) log(x+1))
str(a)
#                  can be identified by stepwise discriminant analysis.)
centaurea = naMeanSubst(centaurea)
centaurea = deletePopulation(centaurea, populationName = c("LIP", "PREL"))
centaurea = keepCharacter(centaurea, c("MLW", "ML", "IW", "LS", "IV", "MW", "MF",
"AP", "IS", "LBA", "LW", "AL", "ILW", "LBS",
"SFT", "CG", "IL", "LM", "ALW", "AW", "SF") )
# add a small constant to characters witch are invariant within taxa
centaurea$data[ centaurea$Taxon == "hybr", "LM" ][1] =
centaurea$data[ centaurea$Taxon == "hybr", "LM" ][1] + 0.000001
centaurea$data[ centaurea$Taxon == "ph", "IV" ][1] =
centaurea$data[ centaurea$Taxon == "ph", "IV" ][1] + 0.000001
centaurea$data[ centaurea$Taxon == "st", "LBS"][1] =
centaurea$data[ centaurea$Taxon == "st", "LBS"][1] + 0.000001
boxMTest(centaurea)
library(heplots)
a = boxMTest(centaurea)
str(a)
cdaRes = cda.calc(centaurea)
str(cdaRes)
classifRes.lda = classif.lda(centaurea, crossval = "indiv")
# exporting results
classif.matrix(classifRes.lda, level = "taxon")
# exporting results
a = classif.matrix(classifRes.lda, level = "taxon")
str(a)
devtools::build_manual()
devtools::build_manual()
devtools::build_manual()
tinytex::tlmgr_install("makeindex")
devtools::build_manual()
library(MorphoTools2)
knitr::opts_chunk$set(
dev="png",
highlight = TRUE,
dpi = 150,
collapse = TRUE,
comment = "#>",
rownames = FALSE,
#fig.width   = 6,
#fig.height  = 5,
fig.align   = 'center'
#fig.path    = 'figs/',
#out.width='\\textwidth'
)
old.par <- par(no.readonly = TRUE)
library(MorphoTools2)
data(centaurea)
summary<-function(object){
cat("Object of class \'morphodata\'\
- contains 33 populations
- contains 4 taxa (defined groups)
Populations: BABL, BABU, BOL, BRT, BUK, CERM, CERV, CZLE, DEB, DOM, DUB, HVLT, KASH,
KOT, KOZH, KRO, LES, LIP, MIL, NEJ, NSED, OLE1, OLE2, PREL, PRIS, PROS, RTE, RUS,
SOK, STCV, STGH, VIT, VOL
Taxa (defined groups): hybr, ph, ps, st\n")
}
summary(centaurea)
rm(summary)
options(max.print = 78)
samples(centaurea)
populations(centaurea)
taxa(centaurea)
characters(centaurea)
options(max.print = 28)
shapiroWilkTest(centaurea)
histCharacter(centaurea, character = "SF")
qqnormCharacter(centaurea, character = "SF")
par(mfrow=c(2,2))
par(mar=c(4,4,2,1))
par(mgp=c(2,0.8,0))
centSquareRoot = transformCharacter(centaurea, character = "SF", FUN = sqrt)
centLog = transformCharacter(centaurea, character = "SF", FUN = function(x) log(x+1))
centCubeRoot = transformCharacter(centaurea, character = "SF", FUN = function(x) x^(1/3))
stats::qqnorm(as.matrix( na.omit(centaurea$data["SF"])), main = "original data", cex = 0.9, bty="n")
stats::qqline(as.matrix( na.omit(centaurea$data["SF"])), lwd=2)
stats::qqnorm(as.matrix( na.omit(centSquareRoot$data["SF"])), main = "sqrt transformed", cex = 0.9, bty="n")
stats::qqline(as.matrix( na.omit(centSquareRoot$data["SF"])), lwd=2)
stats::qqnorm(as.matrix( na.omit(centLog$data["SF"])), main = "log(x+1) transformed",cex = 0.9, bty="n")
stats::qqline(as.matrix( na.omit(centLog$data["SF"])), lwd=2)
stats::qqnorm(as.matrix( na.omit(centCubeRoot$data["SF"])), main = "x^(1/3) transformed", cex = 0.9, bty="n")
stats::qqline(as.matrix( na.omit(centCubeRoot$data["SF"])), lwd=2)
graphics::par(mar=c(3, 4.1, 1.8, 2.1), mgp=c(1.7, 0.6, 0), cex.axis=0.8, cex.lab=0.8, lwd=0.9)
boxplotCharacter(centaurea, character = "AL", col = c("blue","green","red","orange"), cex.main=1.3)
graphics::par(mar=c(3, 4.1, 1.8, 2.1), mgp=c(1.7, 0.6, 0), cex.axis=0.8, cex.lab=0.8, lwd=0.9)
boxplotCharacter(centaurea, character = "AL", pch = 1, cex.main=1.3,
lowerWhisker = 0.1, upperWhisker = 1)
graphics::par(mar=c(3, 4.1, 1.8, 2.1), mgp=c(1.7, 0.6, 0), cex.axis=0.8, cex.lab=0.8, lwd=0.9)
boxplotCharacter(centaurea, character = "AL", outliers = FALSE,cex.main=1.3,
frame = FALSE, horizontal = T, notch = TRUE)
options(max.print = 40)
descrTaxon(centaurea, format = "($MEAN ± $SD)", decimalPlaces = 2)
populOTU <-function(object, crossval="indiv"){
cat("Warning: Unable to calculate the means of characters AL AW ALW AP in
populations LIP PREL. Values are NA.")
}
pops = populOTU(centaurea)
rm(populOTU)
pops = populOTU(centaurea)
tempfile(pattern = "file", tmpdir = tempdir(), fileext = "")
file1 = tempfile(pattern = "file", tmpdir = tempdir(), fileext = "")
tempfile(pattern = "file", tmpdir = tempdir(), fileext = "txt")
tempfile(pattern = "file", tmpdir = tempdir(), fileext = ".txt")
file1 = tempfile(pattern = "file", tmpdir = tempdir(), fileext = ".txt")
data(centaurea)
correlations.p = cormat(centaurea, method = "Pearson")
library(MorphoTools2)
correlations.p = cormat(centaurea, method = "Pearson")
str(correlations.p)
missingSamplesTable(centaurea, level = "pop")
shapiroWilkTest(centaurea)
missingCharactersTable(centaurea, level = "pop")
usethis::use_build_ignore("vignettes/figs/", escape = TRUE)
devtools::build()
morphoDataFrame = data.frame("ID" = c("id1","id2","id3","id4","id5","id6","id7","id8"),
"Population" = c("Pop1", "Pop1", "Pop1", "Pop1", "Pop3", "Pop3", "Pop4", "Pop4"),
"Taxon" = c("TaxA", "TaxA", "TaxA", "TaxA", "TaxB", "TaxB", "TaxB", "TaxB"),
"Ch1" = c(1, 2, NA, 4, 5, 6, NA, NA),
"Ch2" = c(11, NA, 13, NA, 15, NA, 17, 18))
morphoMockup = .morphodataFromDataFrame(morphoDataFrame)
# Class "morphodata"
.morphodataFromDataFrame <- function(indata) {
# check for required columns
if(!("ID" %in% colnames(indata)) | !("Population" %in% colnames(indata)) | !("Taxon" %in% colnames(indata)))
stop("Input do not contain required columns.", call. = FALSE)
data = list(
"ID" = as.factor(indata$ID),
"Population" = as.factor(indata$Population),
"Taxon" = as.factor(indata$Taxon),
"data" = as.data.frame(indata[,-(1:3)],  row.names = as.character(indata$ID))
)
if (dim(indata)[2] == 4) {
colnames(data$data) = colnames(indata)[4]
}
#testuj ci tam nie je nejaky nezmysel .. slovo v cislach etc   .  cislo ako pop?
if (!(is.numeric(as.matrix(data$data)))) stop("Input contains non-numeric data.", call. = FALSE)
attr(data, "class") <- "morphodata"
return(data)
}
morphoMockup = .morphodataFromDataFrame(morphoDataFrame)
meanMockup = naMeanSubst(morphoMockup)
expect_warning(meanMockup = naMeanSubst(morphoMockup))
library(testthat)
expect_warning(meanMockup = naMeanSubst(morphoMockup))
meanMockup = naMeanSubst(morphoMockup)
suppressWarnings(meanMockup = naMeanSubst(morphoMockup))
suppressWarnings("meanMockup = naMeanSubst(morphoMockup)")
morphoDataFrame = data.frame("ID" = c("id1","id2","id3","id4","id5","id6","id7","id8"),
"Population" = c("Pop1", "Pop1", "Pop1", "Pop1", "Pop3", "Pop3", "Pop4", "Pop4"),
"Taxon" = c("TaxA", "TaxA", "TaxA", "TaxA", "TaxB", "TaxB", "TaxB", "TaxB"),
"Ch1" = c(1, 2, NA, 4, 5, 6, NA, NA),
"Ch2" = c(11, NA, 13, NA, 15, NA, 17, 18))
# Class "morphodata"
.morphodataFromDataFrame <- function(indata) {
# check for required columns
if(!("ID" %in% colnames(indata)) | !("Population" %in% colnames(indata)) | !("Taxon" %in% colnames(indata)))
stop("Input do not contain required columns.", call. = FALSE)
data = list(
"ID" = as.factor(indata$ID),
"Population" = as.factor(indata$Population),
"Taxon" = as.factor(indata$Taxon),
"data" = as.data.frame(indata[,-(1:3)],  row.names = as.character(indata$ID))
)
if (dim(indata)[2] == 4) {
colnames(data$data) = colnames(indata)[4]
}
#testuj ci tam nie je nejaky nezmysel .. slovo v cislach etc   .  cislo ako pop?
if (!(is.numeric(as.matrix(data$data)))) stop("Input contains non-numeric data.", call. = FALSE)
attr(data, "class") <- "morphodata"
return(data)
}
morphoMockup = .morphodataFromDataFrame(morphoDataFrame)
suppressWarnings("meanMockup = naMeanSubst(morphoMockup)")
suppressWarnings(expr = "meanMockup = naMeanSubst(morphoMockup)")
testit <- function() warning("testit")
testit() ## shows call
testit() ## no call
suppressWarnings(warning("testit"))
warning("testit")
suppressWarnings(testit())
(testit())
suppressWarnings(testit())
testit() ## shows call
testit <- function() {cat("aa"); warning("testit")}
testit() ## shows call
testit <- function() {cat("aa\n"); warning("testit")}
testit() ## shows call
testit() ## no call
suppressWarnings(testit())
suppressWarnings(naMeanSubst(morphoMockup))
meanMockup = suppressWarnings(naMeanSubst(morphoMockup))
expect_is(meanMockup, "morphodata")
expect_equal(paste(unlist(meanMockup$data), collapse = ","), "1,2,2.333,4,5,6,NA,NA,11,12,13,12,15,15,17,18")
expect_warning(naMeanSubst(morphoMockup), "Unable to replace NAs in characters Ch1 in population Pop4. Probably all values of that character are NA.")
data(centaurea)
centaurea = naMeanSubst(centaurea)
centaurea = suppressWarnings(naMeanSubst(centaurea))
centaurea = deletePopulation(centaurea, populationName = c("LIP", "PREL"))
plotPoints(cdaRes, pch =c(18,16), col = c("red", "green", "blue", "black", "yellow"), cex = 0.5)
cdaRes = cda.calc(centaurea)
plotPoints(cdaRes, pch =c(18,16), col = c("red", "green", "blue", "black", "yellow"), cex = 0.5)
plotCharacters(cdaRes, labels = F)
plot.new()
plotCharacters(cdaRes, axes = c(3,5))
library(MorphoTools2)
# locally suppress warnings
data(centaurea)
cdaRes = cda.calc(centaurea)
centaurea = suppressWarnings(naMeanSubst(centaurea))
centaurea = deletePopulation(centaurea, populationName = c("LIP", "PREL"))
cdaRes = cda.calc(centaurea)
plotCharacters(cdaRes, axes = c(3,5))
dev.off()
dev.off()
devtools::build_manual()
devtools::build_manual()
devtools::build_manual()
devtools::build_manual()
devtools::build_manual()
devtools::build_manual()
devtools::build_manual()
devtools::build_manual()
devtools::build_manual()
devtools::build_manual()
devtools::build_manual()
devtools::build_manual()
# Get the summary of your results
results$cran_summary()
results <- rhub::check_for_cran()
results$cran_summary()
results$cran_summary()
results$cran_summary()
results$cran_summary()
devtools::build(vignettes = TRUE, manual = TRUE)
devtools::build()
devtools::build()
devtools::build()
devtools::build_manual()
devtools::build()
---
library(MorphoTools2)
library(MorphoTools2)
git remote set-url origin https://github.com/MarekSlenker/MorphoTools2
git remote set-url origin "https://github.com/MarekSlenker/MorphoTools2"
git remote -v
devtools::build()
devtools::build()
install.packages("MorphoTools2")
citation(fpc)
library(fpc)
citation(fpc)
library(fpc)
citation(fpc)
citation(fpc)
install.packages("fpc")
citation(fpc)
fpc
citation("fpc")
citation("heplots")
imp = read.morphodata("../testFiles/Impatiens_Pektinata.txt")
imp = read.morphodata("./testFiles/Impatiens_Pektinata.txt")
library(MorphoTools2)
imp = read.morphodata("./testFiles/Impatiens_Pektinata.txt")
imp = read.morphodata("tests/testFiles/Impatiens_Pektinata.txt")
pcoa.calc(imp, distMethod = "euclidean")
# internal
# returns new pcoadata object
.newPcoadata <- function() {
.newPcoadata <- list(
objects = list(
ID = numeric(),
Population = numeric(),
Taxon = numeric(),
scores = numeric()),
eigenvalues = numeric(),
eigenvaluesAsPercentages = numeric(),
cumulativePercentageOfEigenvalues = numeric(),
groupMeans = data.frame(),
distMethod = character(),
rank = numeric()
)
attr(.newPcoadata, "class") <- "pcoadata"
return(.newPcoadata)
}
object=imp
rank = min(length(colnames(object$data)), length(rownames(object$data)))-1 # maximum dimension of the space must be in {1, 2, …, n-1}.
rank
length(colnames(object$data))
length(rownames(object$data))
min(length(colnames(object$data)), length(rownames(object$data)))
min(length(colnames(object$data)), length(rownames(object$data)))-1
xRes = stats::cmdscale(.calcDistance(object, distMethod = distMethod, center = TRUE, scale = TRUE, binaryChs = binaryChs, nominalChs = nominalChs, ordinalChs = ordinalChs),
eig = TRUE) # only to find numb of possitive eigenvalues
.calcDistance <- function(object, distMethod, center, scale, binaryChs, nominalChs, ordinalChs) {
switch (tolower(distMethod),
"euclidean" = {  # moze byt scale alebo nie
return(
stats::dist(scale(object$data, center = center, scale = scale), method = "euclidean")
)
},
"jaccard" = { # ziadne scale
if (any(is.na(object$data))) stop("NA values in 'object'.", call. = FALSE)
return(
ade4::dist.binary(object$data, method = 1, diag = FALSE, upper = FALSE)
)
},
"simplematching" = {
if (any(is.na(object$data))) stop("NA values in 'object'.", call. = FALSE)
return(
ade4::dist.binary(object$data, method = 2, diag = FALSE, upper = FALSE)
)
},
"gower" = {
if (! is.null(binaryChs)) {
object$data[binaryChs] = lapply(object$data[binaryChs], as.logical)
}
if (! is.null(nominalChs)) {
object$data[nominalChs] = lapply(object$data[nominalChs], as.character)
}
if (! is.null(ordinalChs)) {
object$data[ordinalChs] = lapply(object$data[ordinalChs], ordered)
}
return(
stats::as.dist(StatMatch::gower.dist(object$data))
)
},
"manhattan" = {
return(
stats::dist(object$data, method = "manhattan", diag = FALSE, upper = FALSE)
)
},
"minkowski" = {
return(
stats::dist(object$data, method = "minkowski", diag = FALSE, upper = FALSE)
)
},
stop(paste("distMethod \"", distMethod , "\" is not supported.", sep = ""), call. = FALSE)
)
}
distMethod = "Euclidean"
binaryChs = NULL
nominalChs = NULL
ordinalChs = NULL
stats::cmdscale(.calcDistance(object, distMethod = distMethod, center = TRUE, scale = TRUE, binaryChs = binaryChs, nominalChs = nominalChs, ordinalChs = ordinalChs),
eig = TRUE) # only to find numb of possitive eigenvalues
xRes = stats::cmdscale(.calcDistance(object, distMethod = distMethod, center = TRUE, scale = TRUE, binaryChs = binaryChs, nominalChs = nominalChs, ordinalChs = ordinalChs),
eig = TRUE) # only to find numb of possitive eigenvalues
length(xRes$eig[which(xRes$eig > 0)])
length(xRes$eig)
length(xRes$eig[which(xRes$eig > 0)])
xRes$eig[which(xRes$eig > 0)]
xRes$eig
length(xRes$eig[which(xRes$eig > 0)])  # maximum dimension of the space must be in {1, 2, …
rank = length(xRes$eig[which(xRes$eig > 0)])  # maximum dimension of the space must be in {1, 2, …, n-1}.
princompRes = stats::cmdscale(.calcDistance(object, distMethod = distMethod, center = TRUE, scale = TRUE, binaryChs = binaryChs, nominalChs = nominalChs, ordinalChs = ordinalChs),
k = rank, eig = TRUE, x.ret = TRUE)
newNames = NULL
for (i in 1:rank) {
newNames = c(newNames, paste("PCo", i, sep = ""))
}
princompRes$points
rank
newNames
colnames(princompRes$points) = newNames
colnames(princompRes$points)
names(princompRes$eig)
morphoDataFrame = data.frame("ID" = c("id1","id2","id3","id4","id5","id6","id7","id8"),
"Population" = c("Pop1", "Pop1", "Pop2", "Pop2", "Pop3", "Pop3", "Pop4", "Pop4"),
"Taxon" = c("TaxA", "TaxA", "TaxA", "TaxA", "TaxB", "TaxB", "TaxB", "TaxB"),
"Ch1" = c(1,3,4,6,1,7,12,8),
"Ch2" = c(11, 12,42,12,32,11,22,18))
morphoMockup = .morphodataFromDataFrame(morphoDataFrame)
# Class "morphodata"
.morphodataFromDataFrame <- function(indata) {
# check for required columns
if(!("ID" %in% colnames(indata)) | !("Population" %in% colnames(indata)) | !("Taxon" %in% colnames(indata)))
stop("Input do not contain required columns.", call. = FALSE)
data = list(
"ID" = as.factor(indata$ID),
"Population" = as.factor(indata$Population),
"Taxon" = as.factor(indata$Taxon),
"data" = as.data.frame(indata[,-(1:3)],  row.names = as.character(indata$ID))
)
if (dim(indata)[2] == 4) {
colnames(data$data) = colnames(indata)[4]
}
#testuj ci tam nie je nejaky nezmysel .. slovo v cislach etc   .  cislo ako pop?
if (!(is.numeric(as.matrix(data$data)))) stop("Input contains non-numeric data.", call. = FALSE)
attr(data, "class") <- "morphodata"
return(data)
}
# locally suppress warnings
data(centaurea)
centaurea = suppressWarnings(naMeanSubst(centaurea))
centaurea = deletePopulation(centaurea, populationName = c("LIP", "PREL"))
pcoaRes = pcoa.calc(morphoMockup)
morphoMockup = .morphodataFromDataFrame(morphoDataFrame)
pcoaRes = pcoa.calc(morphoMockup)
plotPoints(pcoaRes, axes = c(3,33))
expect_error(plotPoints(pcoaRes, axes = c(3,33)))
plotPoints(pcoaRes, axes = c(1,1,2))
pcoaRes = pcoa.calc(imp, distMethod = "euclidean")
paste(pcoaRes$objects$scores[1:5,1], collapse = "")
paste(round(pcoaRes$objects$scores[1:5,1], digits = 4), collapse = "")
paste(round(pcoaRes$groupMeans[1:3,2], digits = 4), collapse = "")
library(MorphoTools2)
library(MorphoTools2)
devtools::build()
devtools::build()
devtools::build()
---
library(MorphoTools2)
object=centaurea
stats::cmdscale(.calcDistance(object, distMethod = distMethod, center = TRUE, scale = TRUE, binaryChs = binaryChs, nominalChs = nominalChs, ordinalChs = ordinalChs),
eig = TRUE) # only to find numb of possitive eigenvalues
xRes$eig[which(xRes$eig > 0)]
length(xRes$eig)
length(xRes$eig[which(xRes$eig > 0)])
rank =
length(xRes$eig)
rank
princompRes = stats::cmdscale(.calcDistance(object, distMethod = distMethod, center = TRUE, scale = TRUE, binaryChs = binaryChs, nominalChs = nominalChs, ordinalChs = ordinalChs),
k = rank, eig = TRUE, x.ret = TRUE)
princompRes
stats::cmdscale(.calcDistance(object, distMethod = distMethod, center = TRUE, scale = TRUE, binaryChs = binaryChs, nominalChs = nominalChs, ordinalChs = ordinalChs),
k = rank, eig = TRUE, x.ret = TRUE)
princompRes = stats::cmdscale(.calcDistance(object, distMethod = distMethod, center = TRUE, scale = TRUE, binaryChs = binaryChs, nominalChs = nominalChs, ordinalChs = ordinalChs),
k = rank, eig = TRUE, x.ret = TRUE)
newNames = NULL
for (i in 1:rank) {
newNames = c(newNames, paste("PCo", i, sep = ""))
}
colnames(princompRes$points)
newNames
colnames(princompRes$points) = newNames
names(princompRes$eig) = newNames
pcoaResult$rank
pcoaResult = .newPcoadata()
rank
pcoaResult$rank = rank
pcoaResult$eigenvalues = princompRes$eig[1:rank]
pcoaResult$eigenvalues
xRes = stats::cmdscale(.calcDistance(object, distMethod = distMethod, center = TRUE, scale = TRUE, binaryChs = binaryChs, nominalChs = nominalChs, ordinalChs = ordinalChs),
eig = TRUE) # only to find numb of possitive eigenvalues
length(xRes$eig)
rank =
length(xRes$eig)
princompRes = stats::cmdscale(.calcDistance(object, distMethod = distMethod, center = TRUE, scale = TRUE, binaryChs = binaryChs, nominalChs = nominalChs, ordinalChs = ordinalChs),
k = rank, eig = TRUE, x.ret = TRUE)
length(xRes$eig[which(xRes$eig > 0)]) == length(xRes$eig)
length(xRes$eig[which(xRes$eig > 0)])
rank = min(length(colnames(object$data)), length(rownames(object$data)))-1 # maximum dimension of the space must be in {1, 2, …, n-1}.
xRes = stats::cmdscale(.calcDistance(object, distMethod = distMethod, center = TRUE, scale = TRUE, binaryChs = binaryChs, nominalChs = nominalChs, ordinalChs = ordinalChs),
eig = TRUE) # only to find numb of possitive eigenvalues
length(xRes$eig[which(xRes$eig > 0)]) == length(xRes$eig)
length(xRes$eig[which(xRes$eig > 0)])
if (length(xRes$eig[which(xRes$eig > 0)]) == length(xRes$eig)) {
rank = length(xRes$eig)-1  # maximum dimension of the space must be in {1, 2, …, n-1}.
} else {
rank = length(xRes$eig[which(xRes$eig > 0)])  # maximum dimension of the space must be in {1, 2, …, n-1}.
}
rank
princompRes = stats::cmdscale(.calcDistance(object, distMethod = distMethod, center = TRUE, scale = TRUE, binaryChs = binaryChs, nominalChs = nominalChs, ordinalChs = ordinalChs),
k = rank, eig = TRUE, x.ret = TRUE)
newNames = NULL
for (i in 1:rank) {
newNames = c(newNames, paste("PCo", i, sep = ""))
}
colnames(princompRes$points) = newNames
names(princompRes$eig) = newNames
pcoaResult$rank = rank
pcoaResult$rank
pcoaResult$distMethod = distMethod
pcoaResult$objects$scores = princompRes$points
pcoaResult$objects$ID = object$ID
pcoaResult$objects$Population = object$Population
pcoaResult$objects$Taxon = object$Taxon
pcoaResult$eigenvalues = princompRes$eig[1:rank]
pcoaResult$eigenvaluesAsPercentages = round(princompRes$eig/sum(princompRes$eig[1:rank]), 5)[1:rank]
pcoaResult$cumulativePercentageOfEigenvalues = round(cumsum(princompRes$eig[1:rank]/sum(princompRes$eig[1:rank])), 5)[1:rank]
# group centroid locations
pcoaResult$groupMeans = stats::aggregate(princompRes$points ~ object$Taxon, FUN = mean)
colnames(pcoaResult$groupMeans)[1] = "Taxon"
pcoaResult$groupMeans
rank = min(length(colnames(object$data)), length(rownames(object$data)))-1 # maximum dimension of the space must be in {1, 2, …, n-1}.
xRes = stats::cmdscale(.calcDistance(object, distMethod = distMethod, center = TRUE, scale = TRUE, binaryChs = binaryChs, nominalChs = nominalChs, ordinalChs = ordinalChs),
eig = TRUE) # only to find numb of possitive eigenvalues
if (length(xRes$eig[which(xRes$eig > 0)]) == length(xRes$eig)) {
rank = length(xRes$eig)-1  # maximum dimension of the space must be in {1, 2, …, n-1}.
} else {
rank = length(xRes$eig[which(xRes$eig > 0)])  # maximum dimension of the space must be in {1, 2, …, n-1}.
}
rank
princompRes = stats::cmdscale(.calcDistance(object, distMethod = distMethod, center = TRUE, scale = TRUE, binaryChs = binaryChs, nominalChs = nominalChs, ordinalChs = ordinalChs),
k = rank, eig = TRUE, x.ret = TRUE)
object=imp
rank = min(length(colnames(object$data)), length(rownames(object$data)))-1 # maximum dimension of the space must be in {1, 2, …, n-1}.
rank
xRes = stats::cmdscale(.calcDistance(object, distMethod = distMethod, center = TRUE, scale = TRUE, binaryChs = binaryChs, nominalChs = nominalChs, ordinalChs = ordinalChs),
eig = TRUE) # only to find numb of possitive eigenvalues
if (length(xRes$eig[which(xRes$eig > 0)]) == length(xRes$eig)) {
rank = length(xRes$eig)-1  # maximum dimension of the space must be in {1, 2, …, n-1}.
} else {
rank = length(xRes$eig[which(xRes$eig > 0)])  # maximum dimension of the space must be in {1, 2, …, n-1}.
}
rank
min(length(colnames(object$data)), length(rownames(object$data)))-1 # maximum dimension of the space must be in {1, 2, …, n-1}.
load("~/MorphoTools2/stockdata_from_2014-01-01_to_2019-06-25_(47400a7f10aeb92b2d73d32817805b07).RData")
