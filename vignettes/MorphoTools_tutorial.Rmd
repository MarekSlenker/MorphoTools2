---
title: "MorphoTools version 1.0.0 tutorial"
author: |
  | Marek Šlenker \<marek.slenker@savba.sk\>
  | Plant Science and Biodiversity Center
  | Bratislava, Slovakia
  | https://github.com/MarekSlenker/MorphoTools
date: "April 26, 2020"
output:
  pdf_document: default
  word_document: default
  html_document: default
vignette: |
  %\VignetteIndexEntry{MorphoTools_tutorial} %\VignetteEncoding{UTF-8} %\VignetteEngine{knitr::rmarkdown}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

\tableofcontents

# 1. Introduction

The R package MorphoTools provides useful tools for


# 2. Obtaining and installing MorphoTools package

The R console and base system can be obtained at <http://www.r-project.org/>. Once R is installed, MorphoTools can be installed and loaded by typing the following commands into the R console:


```{r eval=FALSE, include=TRUE}
install.packages(MorphoTools)
library(MorphoTools)

```
```{r include=FALSE, eval=TRUE}
library(MorphoTools)
```

If you quit and restart R, you will need to load it again (using the library function as shown above).

# 3. Data import, control and manipulation

## 3.1 Data import

As with any software, the first thing you want to do is import your raw data. Data can be imported from text files, import from Excel spreadsheets through the clipboard in Windows also usually works well. For this tutorial, go into the "extdata" directory of the MorphoTools package installation, and find a file called "centaurea.txt". To find the path to the package location run `path.package(package = "MorphoTools")`. Open this file in a text editor and inspect its contents. This file contains 25 morphological characters of three diploid species of the *Centaurea phrygia* complex, abbreviated "ph", "ps" and "st" and the putative hybrid of the last two species abbreviated as "hybr". For details run `?centaurea`.

As you find in centaurea.txt file, following structure of input data is required: 

* the first row contains variable names.
* the next rows contains individuals, single individual per row.
* the first three columns include unique identifiers for individuals, populations and taxa/groups, respectively. Columns have to be named as “ID”, “Population” and “Taxon”.
* fourth and next columns stores morphological characters.

Avoidi spaces and special characters for column names. Missing values have to be represented as empty cells or by the text `NA` (not quoted).

Read the centaurea.txt file using the `read.morphodata` function, and assign the dataset a name of your choice (centaurea in this example) by typing:


```{r eval = TRUE, echo = TRUE}
centaurea = read.morphodata(file = system.file("extdata", "centaurea.txt", package = "MorphoTools"),
                            dec = ".",
                            sep = "\t")
```

Argument `dec` stands for the character used in the file for decimal points, `sep` is a column delimiter character, usualy whitespace `" "`, coma `","` or tab `"\t"`. Alternatively, you can use build-in data running `data(centaurea)`. The dataset now exists as a `morphodata` object in R. The following commands display, some basic information about the dataset.

```{r echo = TRUE, eval=TRUE}
summary(centaurea)
```

```{r include=F}
options(max.print = 60)
```
```{r echo = TRUE, eval=TRUE}
samples(centaurea)
```

```{r echo = TRUE, eval=TRUE}
populations(centaurea)
```

```{r echo = TRUE, eval=TRUE}
taxa(centaurea)
```


## 3.2 Data control and manipulation

Row data can contain errors (e.g., typos in numbers or in decimal points) and missing values which should be corrected or removed. We should also consider removing significantly correlated characters, that could potentially distort the results of some of the multivariate analyses. Discriminant analyses generally require a multivariate normal distribution of quantitative (not binary) characters within-groups; nevertheless, they have been shown to be considerably robust to deviations in this respect (Thorpe, 1976; Klecka, 1980). Following steps go through these issues and at the end, we will have cleared data ready for exploring the morphological differentiation among the taxa (or any defined groups).

### 3.2.1 Shapiro-Wilk normality test

As the first step, the Shapiro-Wilk statistic for the test of normality of distribution was computed for each character  
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

### 3.2.2 Box Plots

Boxplots are handy tools for detecting outlier values (potential typos). In the later stages, we can use them for detecting between-species dissimilarities and critical morphological values discriminating among species. Exactly these values should be transformed into identification key enabling the correct identification of taxa.  
Boxplots can be calculated for particular character using `boxplot.character()` or for all characters at once running `boxplot.all()` function. In both functions, you can extend whiskers to desired percentiles using `lowerWhisker` and `upperWhisker` arguments. 


```{r echo = TRUE, eval=TRUE, out.width = '280px', dpi=300, fig.align='center'}
boxplot.character(centaurea, character = "AL", lowerWhisker = 0.05,
                   upperWhisker = 0.95, col = c("red","green","blue","orange"))
```

The default behaviour is to plot outliers. As you can see in the above figure, hybrids contain one markedly different value, which will require examination.

### 3.2.3 Descriptive statistics

The table of descriptive statistics is a less comfortable way of detecting outlier values, but it can be used for reporting descriptive statistics of morphological characters in your paper. This statistics can be calculated on the levels of populations, taxa or for the whole dataset, using `descr.pop()`, `descr.tax()` or `descr.all()`, respectively. Using argument `format` you can specify the desired output format. Keywords `$MEAN`, `$SD`, `$MIN`, `$5%`, `$25%`, `$MEDIAN`, `$75%`, `$95%`, `$MAX` will be replaced by actual values. Run `?descr.tax` for more details.

```{r echo = TRUE, eval=TRUE}
descr.tax(centaurea, format = "($MEAN ± $SD)", decimalPlaces = 2)
```

The results can be assigned to a variable and copied to the clipboard (fails for large data) or exported to file using the `export.res()` function.
```{r eval=FALSE, include=TRUE}
descr_tax = descr.tax(centaurea, format = "($MEAN ± $SD)", decimalPlaces = 2)
export.res(descr_tax, file = "clipboard")
export.res(descr_tax, file = "descr_tax.txt")
```

### 3.2.4 Correlations of characters

Highly correlated characters (r > |0.95|) should not be used in principal component analysis and especially in discriminant analysis, as this could potentially distort the results. Function `cormat` calculates the correlation coefficients of the characters, Pearson’s (default) or Spearman’s. The results can be exported with the `export.res()` function. One from the pair of highly correlated character can be removed from dataset using `delete.charecter()` function, see below.

```{r echo = TRUE, eval=TRUE}
correlations.s = cormat(centaurea, method = "spearman")
export.res(correlations.s, file="correlations.spearman.txt")
```

Significance tests are usually unnecessary for morphometric analysis. Anyway, if tests are needed, they can be computed using the `cormat.signifTest()` function.

### 3.2.5 Populations as the taxonomic units

To simplify the overall structure, we can consider the use of populations as operational taxonomic units. This means that the whole population will be represented by a single individual, whose morphological values will be calculated as an average of the individuals' values. Missing values will be removed.

```{r echo = TRUE, eval=TRUE}
pops = popul.otu(centaurea)
```
We received a warning that the values of some characters are `NA`. How to deal with missing data, we will discuss in the following section.


### 3.2.6 Missing data

Missing values are not accepted in morphological analyses, and MorphoTools do not edit user's data in the background. User has to do his own decision, what to do with missing values. Basically, there are two options: remove or replace.

#### Replace missing values    

Missing values can be substituted by the average value of the respective character in the respective population. This approach is acceptable only if: there are relatively few missing values; these missing values are scattered throughout many characters (each character includes only a few missing values); and removing all individuals or all characters with missing data would unacceptably reduce the data set. To substitute missing values by average value, run:

```{r echo = TRUE, eval=TRUE}
centaurea = na.meanSubst(centaurea)
```

#### Remove items  

After the execution of the previous code, we received warnings. Characters AL, AW, ALW, AP in populations LIP and PREL contains only `NA` values. We have to decide between deleting characters using `delete.charecter()` or populations using `delete.population()` function. As character AP looks promising for delimitation of "ps" and "st" taxa, we will keep the characters and remove the populations.

```{r echo = TRUE, eval=TRUE}
centaurea = delete.population(centaurea, populationName = c("LIP", "PREL"))
pops = delete.population(pops, populationName = c("LIP", "PREL"))
```


We examined outlier value in "hybr" group and ensured that data do not contain highly correlated characters. Missing values were replaced by the average values, and populations containing only NAs in some characters were removed.  

Our dataset is now prepared for further analyses. It is not a bad idea to save a copy of it using `export.res()` function. 




# 4. Hierarchical clustering

Hierarchical classification is one of the methods that do not require \emph{a priori} specification of the samples' membership in taxa (groups). Therefore, this method is recommended to use first in order to be able to get an insight on the existence of group structure in your data. Typically, populations are used as OTUs. Characters are standardised to a zero mean and a unit standard deviation using the scale function. Various measures of distance between the observations (rows) are applicable, and various procedures of clustering based on pre-computed distances are available. For further details, run `?clust`.

```{r echo = TRUE, eval=TRUE, out.width = '280px', dpi=300, fig.align='center'}
pops_hierClust = clust(pops, distMethod = "euclidean", clustMethod = "ward")
plot(pops_hierClust, hang = -1, cex = 0.8, sub = "", xlab = "", ylab = "distance")
```

Four main clusters were formed in the histogram above, however, some populations (BABL, LES, PROS, BUK, and NSED) were “incorrectly” clustered, what will require further inspection.



# 5. Principal component analysis (PCA)

Principal components analysis (PCA) is another method without the requirement of \emph{a priori} specification of the samples' membership in taxa (groups). PCA reduce the measured variables into a number of principal components (artificial variables). The first few of them extracts most of the variance in the measured variables. PCA is calculated by `pca.calc()` function, the result is object of class `pcadata` (run `?pcadata` for details). 

```{r echo = TRUE, eval=TRUE, out.width = '280px', dpi=300, fig.align='center'}
pca.centaurea = pca.calc(centaurea)
```

Now we can plot the result by typing following command. As you can see, the first two plotted components extract altogether 53.07% of the overall variability in data.

```{r echo = TRUE, eval=TRUE, out.width = '280px', dpi=300, fig.align='center'}
plot.points(pca.centaurea, col = c("red","green","blue","orange"), pch = c(20,17,8,18), legend = T, 
             ncol = 2, legend.pos="bottomright")

```

The `plot.points()` is a default ploting function. You can add simple legend and point's labels using arguments `labels = TRUE, legend = TRUE`. If you need more precise control about plotting or want to add another elements, use some of the following functions:  

* `plot.addLabels.points()` allows you to inclde or exclude labels, speciffy label's position, offset, colors, etc. 
* `plot.addLegend()` allows you to specify exact coordinates, expansion and interspacing factors, line width, borders parameters, etc. 
* `plot.addEllipses()` draws confidence (prediction) ellipses around taxa.
* `plot.addSpiders()`  connects taxa's points with its centroids, thus forms a "spider" diagram.

```{r echo = TRUE, eval=TRUE, out.width = '280px', dpi=300, fig.align='center'}
pca.pops = pca.calc(pops)

plot.points(pca.pops, col = c("red","green","blue","orange"), pch = c(20,17,8,18), 
            legend = F, labels = F)

plot.addLabels.points(pca.pops, labels = c("PROS","SOK","KASH","BOL","KRO","DUB","MIL",
                      "CERM","DOM" ,"KOZH","KOT"), include = FALSE, pos = 4, cex=0.7)
plot.addLabels.points(pca.pops, labels = c("PROS","SOK","KASH","BOL","CERM", "DOM"), 
                      pos = 2,cex = 0.75)
plot.addLabels.points(pca.pops,labels=c("KRO","MIL","KOZH"),pos=3,offset=0.7,cex=0.75)
plot.addLabels.points(pca.pops, labels=c("DUB","KOT"), pos=1, offset=0.7, cex=0.75)
```

```{r echo = TRUE, eval=TRUE, out.width = '280px', dpi=300, fig.align='center'}
plot.points(pca.centaurea, col = c("red", "green", "blue","black"), cex = 0.5)
plot.addLegend(pca.centaurea, col = c("red", "green", "blue","black"), x = "bottomright", pt.cex = 1.3, box.type = "n" ,ncol = 2)

plot.addSpiders(pca.centaurea,  col = c(rgb(255,0,0,max=255,alpha=130), # red
                                  rgb(0,255,0,max=255,alpha=130), # green
                                  rgb(0,0,255,max=255,alpha=130), # blue
                                  rgb(0,0,0,max=255,alpha=130))) # black
```

```{r echo = TRUE, eval=TRUE, out.width = '280px', dpi=300, fig.align='center'}
plot.points(pca.centaurea, col = c("red", "green", "blue","black"), cex = 0.7)
plot.addLegend(pca.centaurea, col = c("red", "green", "blue","black"), 
               x = "bottomright", pt.cex = 1.3, box.type = "n" ,ncol = 2)

plot.addEllipses(pca.centaurea, col = c("red","green","blue","black"), lwd = 2)

```







# 6. Canonical discriminant analysis (CDA)

Canonical variates analysis (CVA). The method is also known as multigroup discriminant analysis. In this case there
is an a priori grouping of objects and the problem is to find linearly uncorrelated axes by maximizing the distinction
among groups and minimizing the variance within groups in the new space. There is an option to normalize the
eigenvectors such that the resulting group dispersions will be spherical. If the eigenvectors are normalized to unit
length, the scatter of objects will be elliptical in the canonical space. The data must be provided such that the
variables are columns and objects rows, and the size of group is specified before the first object of each group. The
scores are saved in a new file. Each group will appear in a different color when the ordination results are displayed.

On
the basis of the groupings revealed by PCA



## How to cite MorphoTools

sssssssssssssssssssssssssssssssssssssss

Feel free to email me at marek.slenker@savba.sk with any questions, comments, or bug reports!

## References

**Klecka WR. 1980**. *Discriminant analysis (No. 19)*. Sage University Paper Series on Quantitative Applications in the Social Sciences 07-019.

**Krzanowski W. 1990**. *Principles of multivariate analysis*. Oxford: Oxford University Press.

**Thorpe RS. 1976**. Biometric analysis of geographic variation and racial affinities. *Biological Reviews of the Cambridge Philosophical Society* **51**: 407–425.
